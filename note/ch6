Chapter 06. 하위 설계

요약

01. 모듈화
	해결하기 어려운 큰 문제를 작은 단위로 쪼개 하나씩 해결하는 것처럼, 소프트웨어 개발 작업을 실제로 개발할 수 있는 작은 단위로 나누는 것이다.

02. 응집도
	모듈 내부에 존재하는 구성 요소들 사이의 밀접한 정도로, 하나의 모듈 안에서 구성 요소들 간에 똘똘 뭉쳐 있는 정도로 평가한다. 응집도가 높을수록 구성 요소들이 꼭 필요한 것들로만 모여 있고, 응집도가 낮을수록 서로 관련성이 적은 요소들이 모여 있다.

03. 결합도
	모듈과 모듈 사이의 관계에서 관련 정도를 나타낸다. 모듈 간에는 관련이 적을수록 상호 의존성이 줄어 모듈의 독립성이 높아지고, 독립성이 높으면 모듈 간에 영향이 적어 좋은 설계가 된다.

*04. 모듈 간의 좋은 관계
	모듈 간에는 꼭 필요한 데이터만 주고받는 것이 좋다. 그러려면 제어 플래그보다는 데이터를 매개변수로 사용하는 것이 좋다. 그래야 유지보수 용이성을 높일 수 있다. 설계를 할 때 가장 좋은 형태는 모듈 간의 결합도는 낮게, 응집도는 높게 하는 것이다.
	-> 결론은 응근(결합도는 약하게 응집도는 강하게)

05. 프로세스 지향 방법의 특징
• 프로세스와 데이터가 분리되어 있다.
• 실세계를 컴퓨터 처리 방식으로 표현한다.
• 함수 중심(우선)으로 모듈을 구성한다.

06. 프로세스 지향 방법과 데이터 지향 방법의 문제점
• 변경이 미치는 영향이 크다.
• 프로그램 복잡도가 증가한다.
• 프로그램 변경 시 프로그램 구조를 상세히 파악해야 한다.
• 재사용이 어렵다.

07. 객체지향 방법
프로세스 지향 방법과 데이터 지향 방법의 문제점을 해결하기 위해 고안된 것으로, 기능이나 데이터 대신 객체가 중심이 되어 개발된다. 데이터(속성)를 가장 먼저 찾고 그 데이터를 조작하는 메서드(함수)를 찾아 그 둘을 객체라는 이름으로 묶어 그 객체를 중심으로 모듈을 구성한다. 따라서 이 객체 속에는 기능과 데이터가 모두 포함되어 있다.

//객체지향의 주요 개념과 특징
캡슐화
정보은닉
상속
다형성


08. 클래스
공통되는 것들을 묶어서 대표적인 이름을 붙인 것이다. 클래스가 개념적이라면, 객체는 구체적이라 할 수 있다.

09. 인스턴스
같은 클래스에 속하는 개개의 객체로, 하나의 클래스에서 생성된 객체를 말한다. 즉 클래스가 구체화되어, 클래스에서 정의된 속성과 성질을 가진 실제적인 객체로 표현된 것을 의미한다.

*10. 캡슐화
사용자들에게 해당 객체의 기능(서비스)과 사용법만 제공하고 내부는 감추어(변경할 수 없게 함) 쉽게 사용할 수 있게 하는 개념이다.

@ 객체지향 방식에서 캡슐화를 통해 얻을 수 있는 장점이 아닌 것을 고르시오. 
1) 캡슐화(데이터+메서드)로 인해 객체 사이의 독립성이 구조적으로 보장된다. 
2) 메서드의 기능만 알면 객체를 사용할 수 있다. 
3) 데이터와 메서드의 오버로딩을 피하고 기존 클래스에 있는 것을 재사용할 수 있다.(x) -> 상속의 장점
4) 객체 제공자와 객체 이용자(외부 객체)의 분담을 명확히 할 수 있다.

11. 정보은닉
한 모듈에서 인터페이스와 구현을 명확히 분리하여 각 모듈의 내부 항목에 관한 정보는 감추고, 인터페이스를 통해서만 메시지를 전달함으로써 다른 모듈을 변경하지 못하도록 한다.

상속의 장점
•이해 용이 : 개별 클래스를 상속 관계로 묶음으로써 클래스 간의 체계화된 전체 구조를 파악하기 쉽다.
•재사용성 증대 : 데이터와 메서드의 오버로딩을 피하고 기존 클래스에 있는 것을 재사용할 수 있다.
•확장 용이 : 새로운 클래스, 데이터, 메서드를 추가하기가 쉽다.
•유지보수 용이 : 데이터와 메서드를 변경할 때 상위에 있는 것만 수정하여 전체적으로 일관성을 유지할 수 있다.
•추상화 가능 : 일반화(generalization), 특수화(specialization)의 관계를 통해 추상화 단계를 표현할 수 있다

// 다형성

12. 메서드 오버로딩
=> 추상 클래스와 추상 메서드만 사용할 수 있다
•한 클래스에 이름이 동일한 메서드가 중복 정의되어 있는 경우를 메서드 오버로딩(overloading)이라 한다
•연산자 하나를 다른 용도로 다시 중복 정의하여 사용하는 것인데, 이를 연산자 오버로딩이라고 한다
•상속 구조에서 메서드 오버로딩은 한 클래스 안의 메서드 오버로딩과 사용 형태가 다르다. 한 클래스에서는 매개변수의 타입과 개수로 구별했지만 상속 구조에서는 메서드명뿐 아니라 매개변수의 타입과 개수까지 같다
•면적 구하는 area() 메서드가 하위 클래스마다 다르게 구현되므로 특정 객체의 면적 구하는 메서드는 프로그램의 실행 시간에 호출된다. 이러한 의미에서 다형성을 동적 바인딩(dynamic binding) 또는 늦은 바인딩(late binding)이라고도 한다

13. 메서드 오버라이딩
•메서드 오버로딩이 추상 클래스와 추상 메서드만 사용할 수 있는 반면, 메서드 오버라이딩은 추상 클래스와 일반 클래스를 모두 다 사용할 수 있다. 또한 상위 클래스에서 정의한 일반 메서드의 구현을 하위 클래스에서 모두 무시하고 다시 재정의해서 사용할 수 있다.
•그러므로 상위 클래스에 정의된 메서드와 하위 클래스에서 사용된 이 메서드는 이름은 같지만 구현이 전혀 다르다. 메서드를 오버라이딩하면 상위 클래스의 메서드는 은닉(무시)되고, 하위 클래스의 메서드가 사용

@ 다음 중 다형성과 관련된 설명을 틀리게 짝지은 것을 고르시오
1) 오버로딩 - 중복 정의 - 추상 클래스 상속 - 시그니처 - 이름 동일
2) 오버라이딩 - 재정의 - 일반 클래스 상속 - 이름 동일
3) 오버로딩 - 동적 바인딩 - 일반 클래스 상속 - 구현 다름 (x) => 추상화 클래스 상속, 상속구조에서 메서드 오버로딩
4) 오버라이딩 - 메서드 은닉 - 추상 클래스 상속 - 구현 다름

// 클래스 간의 관계
14. 연관 관계
서로 알고 지내는 정도의 관계로, 하나의 클래스가 또 다른 클래스를 인지하고 있음을 의미한다. 따라서 두 클래스는 서로 메시지를 주고받으며 이용하는 관계가 된다.
ex) 사장,salary() <-> 직원, work()

15. 일반화-특수화 관계
두 클래스 간의 상속 관계를 말한다. 하위 클래스는 상위 클래스의 각 속성과 메서드를 모두 상속받아 사용한다. 즉 하위 클래스는 원래 가지고 있던 고유의 속성과 연산뿐 아니라 상위 클래스에서 물려받은 속성과 연산까지 모두 사용하게 된다.
ex) 도형, area() - 삼각형, 사각형, 원

16. 집합 관계와 포함 관계
집합 관계는 연관 관계를 더 구체적으로 나타낸 것으로, 거대한 객체 하나를 소규모 객체 여러 개로 구성할 때 발생할 수 있다. 즉 전체와 부분 관계가 성립한다.
ex) 컴퓨터 - 모니터/본체/키보드

그러나 전체 객체에 완전히 전속되어 독립된 객체로 존재할 수 없는 부분 객체도 있는데, 이와 같은 관계를 특별히 포함 관계라고 한다. 포함 관계의 부분 객체들은 전체 객체가 없어지면 같이 없어진다.
ex) 노트북 - 모니터/본체/키보드

17. 클래스 설계 원칙
• 단일 책임 원칙(SRP: Single-Responsibility Principle) : 클래스를 변경해야 하는 이유는 오직 하나여야 한다.
• 개방 폐쇄의 원칙(OCP: Open-Closed Principle) : 확장(상속)에는 열려 있어야 하고 변경에는 닫혀 있어야 한다.
• 리스코프 교체의 원칙(LSP: Liskov Substitution Principle) : 기반 클래스는 파생 클래스로 대체할 수 있어야 한다.
• 의존 관계 역전의 원칙(DIP: Dependency Inversion Principle) : 클라이언트는 구체 클래스가 아닌 추상 클래스(인터페이스)에 의존해야 한다.
• 인터페이스 분리의 원칙(ISP: Interface Segregation Principle) : 하나의 일반적인 인터페이스보다는 구체적인 여러 개의 인터페이스가 낫다.

[네이버 지식백과] 요약 (쉽게 배우는 소프트웨어 공학, 2015. 11. 30., 김치수)
